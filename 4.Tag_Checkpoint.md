

Die referenzielle Integrität ist ein zentrales Prinzip in relationalen Datenbanken, das sicherstellt, dass Beziehungen zwischen Tabellen konsistent bleiben.  

1. **Erläuterung des Prinzips der referentiellen Integrität (C3G):**  
   - Die referenzielle Integrität stellt sicher, dass Fremdschlüsselwerte immer auf gültige Primärschlüsselwerte verweisen.  
   - Es verhindert, dass Datensätze in einer Tabelle existieren, die auf nicht existierende Datensätze in einer anderen Tabelle verweisen.  
   - Dies wird durch Einschränkungen (Constraints) wie `FOREIGN KEY` und entsprechende Aktionen definiert.  

2. **Auswirkungen von Löschen und Ändern von Daten auf die referenzielle Integrität (C3F):**  
   - Löscht man einen Primärschlüsselwert, auf den Fremdschlüssel verweisen, entstehen „verwaiste“ Datensätze, falls keine Maßnahmen getroffen werden.  
   - Änderungen an Primärschlüsseln erfordern eine Anpassung der referenzierenden Fremdschlüssel oder können zu Inkonsistenzen führen.  
   - Ohne geeignete Regeln könnten Abfragen falsche oder unvollständige Daten liefern.  

3. **Anwendung von Regeln zur Sicherstellung der Datenbankkonsistenz (C3E):**  
   - **Löschweitergabe (`ON DELETE CASCADE`)**: Beim Löschen eines Primärschlüssels werden alle referenzierenden Datensätze ebenfalls gelöscht.  
   - **Setzen auf NULL (`ON DELETE SET NULL`)**: Beim Löschen eines Primärschlüssels wird der Fremdschlüsselwert in den referenzierenden Datensätzen auf NULL gesetzt.  
   - **Einschränkung (`ON DELETE RESTRICT` oder `ON DELETE NO ACTION`)**: Verhindert das Löschen eines Primärschlüssels, wenn noch abhängige Fremdschlüssel existieren.  
   - **Aktualisierungsweitergabe (`ON UPDATE CASCADE`)**: Änderungen am Primärschlüsselwert werden automatisch in allen referenzierenden Fremdschlüsseln übernommen.  

Durch die konsequente Anwendung dieser Regeln wird die Konsistenz und Integrität der Datenbank gewährleistet.

---
### **1. Referenzielle Integrität**  
Referenzielle Integrität stellt sicher, dass Beziehungen zwischen Tabellen in einer Datenbank konsistent bleiben. Das bedeutet, dass ein Fremdschlüssel (Foreign Key) nur auf vorhandene Primärschlüssel (Primary Key) in einer anderen Tabelle verweisen darf.  

#### **Beispiel:**  
Wir haben zwei Tabellen:  

**Kunde (Customer)**  
| KundeID (Primary Key) | Name     |  
|----------------------|---------|  
| 1                   | Alice   |  
| 2                   | Bob     |  

**Bestellung (Order)**  
| BestellID (Primary Key) | KundeID (Foreign Key) | Produkt  |  
|----------------------|-------------------|---------|  
| 101                  | 1                 | Laptop  |  
| 102                  | 2                 | Handy   |  
| 103                  | 3                 | Tablet  | ❌ **(Fehler: Kein Kunde mit ID 3!)**  

In diesem Beispiel verstösst die dritte Bestellung gegen die referenzielle Integrität, da es keinen Kunden mit **KundeID = 3** gibt.  

---

### **2. Constraints (Einschränkungen in einer Datenbank)**  
Constraints sind Regeln, die helfen, die Datenbankintegrität sicherzustellen.  

**Wichtige Constraints:**  
- **PRIMARY KEY** – Stellt sicher, dass eine Spalte eindeutige Werte hat.  
- **FOREIGN KEY** – Stellt Beziehungen zwischen Tabellen sicher.  
- **NOT NULL** – Erlaubt keine NULL-Werte.  
- **UNIQUE** – Stellt sicher, dass alle Werte in einer Spalte einzigartig sind.  
- **CHECK** – Definiert Bedingungen für gültige Werte.  
- **DEFAULT** – Gibt Standardwerte vor.  

#### **Beispiel:**  
```sql
CREATE TABLE Kunde (
    KundeID INT PRIMARY KEY,
    Name VARCHAR(50) NOT NULL
);

CREATE TABLE Bestellung (
    BestellID INT PRIMARY KEY,
    KundeID INT,
    Produkt VARCHAR(50) NOT NULL,
    FOREIGN KEY (KundeID) REFERENCES Kunde(KundeID)
);
```
Hier stellen **PRIMARY KEY**, **NOT NULL** und **FOREIGN KEY** sicher, dass die Daten konsistent bleiben.

---

---
### **Referenzielle Integrität
Die **referenzielle Integrität** stellt sicher, dass Fremdschlüsselwerte gültig sind und mit einem existierenden Primärschlüssel in der referenzierten Tabelle übereinstimmen.  

**Beispiel:**  
- Tabelle `Kunde`:
  ```sql
  CREATE TABLE Kunde (
      kunde_id INT PRIMARY KEY,
      name VARCHAR(100)
  );
  ```
- Tabelle `Bestellung` mit Fremdschlüssel auf `Kunde.kunde_id`:
  ```sql
  CREATE TABLE Bestellung (
      bestell_id INT PRIMARY KEY,
      kunde_id INT,
      datum DATE,
      FOREIGN KEY (kunde_id) REFERENCES Kunde(kunde_id) ON DELETE CASCADE
  );
  ```
- **Referenzielle Integrität sichert, dass keine Bestellung mit einer `kunde_id` eingefügt wird, die nicht in `Kunde` existiert.**  
- Falls ein Kunde gelöscht wird, werden mit **`ON DELETE CASCADE`** alle seine Bestellungen automatisch gelöscht.

---

### **Welche Constraints kann eine Beziehung haben?**  
Eine Beziehung kann verschiedene **Constraints** haben:  

1. **PRIMARY KEY (PK)** – Eindeutige Identifikation der Datensätze.  
2. **FOREIGN KEY (FK)** – Stellt sicher, dass der Wert in einer anderen Tabelle existiert.  
3. **ON DELETE / ON UPDATE CASCADE** – Steuerung, was mit abhängigen Daten geschieht, wenn sich die referenzierte Zeile ändert oder gelöscht wird.  
4. **UNIQUE** – Stellt sicher, dass der Wert in einer Spalte einzigartig ist.  
5. **NOT NULL** – Verhindert, dass NULL-Werte gespeichert werden.  
6. **CHECK** – Setzt Bedingungen für gültige Werte einer Spalte.  

**Beispiel:**  
```sql
ALTER TABLE Bestellung
ADD CONSTRAINT fk_kunde FOREIGN KEY (kunde_id) 
REFERENCES Kunde(kunde_id) ON DELETE CASCADE;
```

---

### **Unterschied zwischen LEFT JOIN und RIGHT JOIN**  

| JOIN-Typ | Was wird angezeigt? |
|----------|---------------------|
| **LEFT JOIN** | Alle Datensätze aus der linken Tabelle + passende aus der rechten Tabelle. Falls keine Übereinstimmung, dann NULL für rechte Tabelle. |
| **RIGHT JOIN** | Alle Datensätze aus der rechten Tabelle + passende aus der linken Tabelle. Falls keine Übereinstimmung, dann NULL für linke Tabelle. |

**Beispiel:**  
```sql
SELECT k.name, b.bestell_id 
FROM Kunde k 
LEFT JOIN Bestellung b ON k.kunde_id = b.kunde_id;
```
- Zeigt **alle Kunden**, auch wenn sie keine Bestellung haben (NULL in `bestell_id`).  

```sql
SELECT k.name, b.bestell_id 
FROM Kunde k 
RIGHT JOIN Bestellung b ON k.kunde_id = b.kunde_id;
```
- Zeigt **alle Bestellungen**, auch wenn kein Kunde dazu existiert (NULL in `name`).

---

### **Wie wird eine 1:1-Beziehung und eine c:m-Beziehung umgesetzt? Warum?**  

#### **1:1-Beziehung**  
- Eine **1:1-Beziehung** bedeutet, dass ein Datensatz in Tabelle A genau einen passenden Datensatz in Tabelle B hat.  
- Umsetzung durch einen **Fremdschlüssel mit `UNIQUE` Constraint**:  
  ```sql
  CREATE TABLE Person (
      person_id INT PRIMARY KEY,
      name VARCHAR(100)
  );

  CREATE TABLE Personalausweis (
      ausweis_id INT PRIMARY KEY,
      person_id INT UNIQUE,
      nummer VARCHAR(50),
      FOREIGN KEY (person_id) REFERENCES Person(person_id) ON DELETE CASCADE
  );
  ```
- **Warum?**  
  - Der `UNIQUE`-Constraint verhindert, dass mehrere Ausweise einer Person zugeordnet werden.  

---

#### **c:m-Beziehung (Viele-zu-Viele, n:m)**  
- **Erfordert eine Zwischentabelle (Join-Tabelle)** mit zwei Fremdschlüsseln:  
  ```sql
  CREATE TABLE Student (
      student_id INT PRIMARY KEY,
      name VARCHAR(100)
  );

  CREATE TABLE Kurs (
      kurs_id INT PRIMARY KEY,
      titel VARCHAR(100)
  );

  CREATE TABLE Student_Kurs (
      student_id INT,
      kurs_id INT,
      PRIMARY KEY (student_id, kurs_id),
      FOREIGN KEY (student_id) REFERENCES Student(student_id),
      FOREIGN KEY (kurs_id) REFERENCES Kurs(kurs_id)
  );
  ```
- **Warum?**  
  - Ein Student kann mehrere Kurse belegen, und ein Kurs kann mehrere Studenten haben.  
  - Die **Zwischentabelle** verknüpft beide Tabellen durch **Primär- und Fremdschlüssel**.

---

### **Nachteile, wenn eine Beziehung nur mit Primär- und Fremdschlüssel definiert wird, ohne Constraints?**  
- **Dateninkonsistenz:** Es könnten Einträge mit falschen oder fehlenden Fremdschlüsselwerten existieren.  
- **Löschprobleme:** Löscht man einen Primärschlüssel, bleiben verwaiste Fremdschlüsseleinträge zurück.  
- **Keine automatische Aktualisierung:** Änderungen am Primärschlüssel müssen manuell in der Fremdschlüsselspalte angepasst werden.  

**Beispiel:**  
Ohne `ON DELETE CASCADE` bleibt eine Bestellung ohne gültigen Kunden bestehen, wenn der Kunde gelöscht wird.

---

### **Folge eines Fremdschlüsseleintrags mit nicht vorhandenem ID-Wert**  

**a) Mit Constraint-Anweisung auf dem FS (`FOREIGN KEY`)**  
- **Fehler**: Die Datenbank verhindert den Eintrag, da keine passende `ID` existiert.  
- **Beispiel:**  
  ```sql
  INSERT INTO Bestellung (bestell_id, kunde_id, datum) 
  VALUES (1, 999, '2025-01-01'); -- Fehler, wenn 999 kein Kunde ist!
  ```

**b) Ohne Constraint-Anweisung auf dem FS**  
- **Erlaubt**: Das System speichert den ungültigen Fremdschlüsselwert.  
- **Folge**: Dateninkonsistenz – es gibt eine Bestellung, aber keinen passenden Kunden.  
- **Problem:** JOIN-Abfragen zeigen fehlerhafte Ergebnisse oder NULL-Werte.  

---
